name: BuildJet Runner - Multi-Repository Build (Multi-Job)

# Performance Optimizations:
# - Uses caching for metrics data sharing between jobs (faster than artifacts)
# - Parallel job execution: build-summary, status-check, and notify run in parallel

run-name: "Demo-CI-${{ inputs.build_type || github.event.client_payload.build_type }}-${{ github.event.client_payload.build_date || 'YYYY-MM-DD' }}-${{ github.run_number }}"

on:
  # Repository dispatch from source repositories
  repository_dispatch:
    types: [application-updated, static-library-updated]
  
  # Manual trigger for testing
  workflow_dispatch:
    inputs:
      build_target:
        description: 'What to build'
        required: true
        default: 'all'
        type: choice
        options:
        - all
        - library
        - application
      build_type:
        description: 'Build type'
        required: true
        default: 'release'
        type: choice
        options:
        - release
        - debug
      artifacts_retention:
        description: 'Artifacts retention (days)'
        required: false
        default: '5'
        type: string

jobs:
  build:
    runs-on: buildjet-16vcpu-ubuntu-2204
    
    # Job outputs to pass data to subsequent jobs
    outputs:
      build-type: ${{ steps.config.outputs.build_type }}
      save-logs: ${{ steps.config.outputs.save_logs }}
      source-repo: ${{ steps.config.outputs.source_repo }}
      source-sha: ${{ steps.config.outputs.source_sha }}
      source-ref: ${{ steps.config.outputs.source_ref }}
      pr-number: ${{ steps.config.outputs.pr_number }}
      trigger-reason: ${{ steps.config.outputs.trigger_reason }}
      library-status: ${{ steps.build-library.outcome }}
      application-status: ${{ steps.build-application.outcome }}
      tests-status: ${{ steps.run-tests.outcome }}
      build-start-time: ${{ steps.metrics-init.outputs.build_start_time }}
      build-date: ${{ steps.metrics-init.outputs.build_date }}
    
    env:
      # Artifact retention configuration (in days)
      # Used for both build artifacts and logs
      BUILD_ARTIFACTS_RETENTION: ${{ inputs.artifacts_retention || '5' }}
      # Build start time for metrics
      BUILD_START_TIME: ${{ github.event.repository.pushed_at }}
    
    steps:
    - name: Initialize build metrics
      id: metrics-init
      run: |
        echo "=== Initializing Build Metrics ==="
        BUILD_START=$(date +%s)
        BUILD_DATE="${{ github.event.client_payload.build_date || ''}}"
        
        # Generate current date if not provided (for manual triggers)
        if [[ -z "$BUILD_DATE" ]]; then
          BUILD_DATE=$(date '+%Y-%m-%d')
          echo "üóìÔ∏è  Generated build date: $BUILD_DATE"
        else
          echo "üóìÔ∏è  Received build date: $BUILD_DATE"
        fi
        
        echo "build_start_time=$BUILD_START" >> $GITHUB_OUTPUT
        echo "build_date=$BUILD_DATE" >> $GITHUB_OUTPUT
        echo "üïê Build started at: $(date -d @$BUILD_START '+%Y-%m-%d %H:%M:%S UTC')"
        
        # Create metrics file
        mkdir -p /tmp/metrics
        echo "step,start_time,end_time,duration_seconds,status" > /tmp/metrics/build_metrics.csv
        echo "build_init,$BUILD_START,," >> /tmp/metrics/build_metrics.csv
        
        echo "metrics_file=/tmp/metrics/build_metrics.csv" >> $GITHUB_OUTPUT
    
    - name: Extract build configuration
      id: config
      run: |
        STEP_START=$(date +%s)
        echo "=== Extracting Build Configuration ==="
        
        # Debug repository dispatch payload
        if [[ "${{ github.event_name }}" == "repository_dispatch" ]]; then
          echo "üîç Repository Dispatch Debug:"
          echo "  Event Action: ${{ github.event.action }}"
          echo "  Build Type: '${{ github.event.client_payload.build_type }}'"
          echo "  Save Logs: '${{ github.event.client_payload.save_logs }}'"
          echo "  Repository: '${{ github.event.client_payload.repository }}'"
          echo "  SHA: '${{ github.event.client_payload.sha }}'"
          echo "  Ref Name: '${{ github.event.client_payload.ref_name }}'"
          echo "  PR Number: '${{ github.event.client_payload.pr_number }}'"
          echo "  Build Date: '${{ github.event.client_payload.build_date }}'"
          echo "  Commit Message: '${{ github.event.client_payload.commit_message }}'"
        fi
        
        # Default values
        BUILD_TYPE="release"
        SAVE_LOGS="false"
        TRIGGER_REASON="Manual build"
        SOURCE_REPO="unknown"
        SOURCE_SHA="unknown"
        SOURCE_REF="unknown"
        PR_NUMBER=""
        
        # Extract from repository dispatch payload
        if [[ "${{ github.event_name }}" == "repository_dispatch" ]]; then
          BUILD_TYPE="${{ github.event.client_payload.build_type || 'release' }}"
          SAVE_LOGS="${{ github.event.client_payload.save_logs || 'false' }}"
          TRIGGER_REASON="${{ github.event.client_payload.commit_message || 'Repository dispatch trigger' }}"
          SOURCE_REPO="${{ github.event.client_payload.repository || 'unknown' }}"
          SOURCE_SHA="${{ github.event.client_payload.sha || 'unknown' }}"
          SOURCE_REF="${{ github.event.client_payload.ref_name || 'unknown' }}"
          PR_NUMBER="${{ github.event.client_payload.pr_number || '' }}"
          
          echo "üì° Repository Dispatch Event: ${{ github.event.action }}"
          echo "üèóÔ∏è  Build Type: $BUILD_TYPE"
          echo "üìù Save Logs: $SAVE_LOGS"
          echo "üìÅ Source Repo: $SOURCE_REPO"
          echo "üîó Source SHA: $SOURCE_SHA"
          echo "üåø Source Branch: $SOURCE_REF"
          echo "üìù PR Number: '$PR_NUMBER'"
          echo "üí¨ Reason: $TRIGGER_REASON"
        fi
        
        # Extract from manual workflow dispatch
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          BUILD_TYPE="${{ inputs.build_type || 'release' }}"
          SAVE_LOGS="false"  # Manual triggers don't have save_logs input yet
          TRIGGER_REASON="Manual workflow dispatch"
          
          echo "üéÆ Manual Workflow Dispatch"
          echo "üèóÔ∏è  Build Type: $BUILD_TYPE"
          echo "üéØ Target: ${{ inputs.build_target || 'all' }}"
        fi
        
        # Set outputs for use in subsequent steps
        echo "build_type=$BUILD_TYPE" >> $GITHUB_OUTPUT
        echo "save_logs=$SAVE_LOGS" >> $GITHUB_OUTPUT
        echo "trigger_reason=$TRIGGER_REASON" >> $GITHUB_OUTPUT
        echo "source_repo=$SOURCE_REPO" >> $GITHUB_OUTPUT
        echo "source_sha=$SOURCE_SHA" >> $GITHUB_OUTPUT
        echo "source_ref=$SOURCE_REF" >> $GITHUB_OUTPUT
        echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
        
        echo "" 
        echo "=== Configuration Summary ==="
        echo "Build Type: $BUILD_TYPE"
        echo "Save Logs: $SAVE_LOGS"
        echo "Trigger: $TRIGGER_REASON"
        echo "üì¶ Artifacts Retention: ${{ env.BUILD_ARTIFACTS_RETENTION }} days"
        
        # Record step completion
        STEP_END=$(date +%s)
        STEP_DURATION=$((STEP_END - STEP_START))
        echo "config,$STEP_START,$STEP_END,$STEP_DURATION,success" >> ${{ steps.metrics-init.outputs.metrics_file }}
        echo "‚è±Ô∏è  Configuration extraction took: ${STEP_DURATION}s"
    
    - name: Checkout build repository
      uses: actions/checkout@v4
    
    - name: Setup workspace with manifest
      id: setup-workspace
      run: |
        STEP_START=$(date +%s)
        echo "=== Setting up workspace using manifest ==="
        
        # Install Google Repo tool
        mkdir -p ~/.local/bin
        curl -s https://storage.googleapis.com/git-repo-downloads/repo > ~/.local/bin/repo
        chmod +x ~/.local/bin/repo
        export PATH="$HOME/.local/bin:$PATH"
        
        # Verify repo tool installation
        repo --version
        
        # Configure git (required by repo)
        git config --global user.name "GitHub Actions"
        git config --global user.email "actions@github.com"
        
        # Create workspace using manifest
        mkdir workspace
        cd workspace
        
        # Initialize repo workspace with manifest
        repo init -u https://github.com/Demo-CI/manifest.git -m default.xml
        
        # Sync all repositories
        repo sync -j4
        
        # Verify workspace structure
        echo "=== Workspace structure ==="
        ls -la
        echo "=== Repository list ==="
        repo list
        echo "=== Repository status ==="
        repo status
        
        echo "Workspace setup complete using manifest"
        
        # Record step completion
        STEP_END=$(date +%s)
        STEP_DURATION=$((STEP_END - STEP_START))
        echo "workspace_setup,$STEP_START,$STEP_END,$STEP_DURATION,success" >> ${{ steps.metrics-init.outputs.metrics_file }}
        echo "‚è±Ô∏è  Workspace setup took: ${STEP_DURATION}s"
    
    - name: Install build dependencies
      id: install-deps
      run: |
        STEP_START=$(date +%s)
        echo "=== Installing build dependencies ==="
        
        sudo apt-get update
        sudo apt-get install -y \
          build-essential \
          cppcheck \
          clang-format \
          valgrind \
          doxygen \
          graphviz
        
        # Record step completion
        STEP_END=$(date +%s)
        STEP_DURATION=$((STEP_END - STEP_START))
        echo "install_deps,$STEP_START,$STEP_END,$STEP_DURATION,success" >> ${{ steps.metrics-init.outputs.metrics_file }}
        echo "‚è±Ô∏è  Dependency installation took: ${STEP_DURATION}s"
    
    - name: Determine build strategy
      id: strategy
      run: |
        STEP_START=$(date +%s)
        echo "=== Determining build strategy ==="
        
        if [[ "${{ github.event_name }}" == "repository_dispatch" ]]; then
          trigger_type="${{ github.event.action }}"
          echo "Repository dispatch trigger: $trigger_type"
          
          case "$trigger_type" in
            "application-updated")
              echo "Building library + application (application updated)"
              echo "build_library=true" >> $GITHUB_OUTPUT
              echo "build_application=true" >> $GITHUB_OUTPUT
              ;;
            "static-library-updated")
              echo "Building library + application (library updated)"
              echo "build_library=true" >> $GITHUB_OUTPUT
              echo "build_application=true" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "Unknown trigger, building all"
              echo "build_library=true" >> $GITHUB_OUTPUT
              echo "build_application=true" >> $GITHUB_OUTPUT
              ;;
          esac
        else
          # Manual trigger
          build_target="${{ github.event.inputs.build_target || 'all' }}"
          echo "Manual trigger: $build_target"
          
          case "$build_target" in
            "library")
              echo "build_library=true" >> $GITHUB_OUTPUT
              echo "build_application=false" >> $GITHUB_OUTPUT
              ;;
            "application")
              echo "build_library=true" >> $GITHUB_OUTPUT
              echo "build_application=true" >> $GITHUB_OUTPUT
              ;;
            "all"|*)
              echo "build_library=true" >> $GITHUB_OUTPUT
              echo "build_application=true" >> $GITHUB_OUTPUT
              ;;
          esac
        fi
        
        echo "Build strategy determined:"
        echo "- Build library: $(grep 'build_library=' $GITHUB_OUTPUT | cut -d'=' -f2)"
        echo "- Build application: $(grep 'build_application=' $GITHUB_OUTPUT | cut -d'=' -f2)"
        
        # Record step completion
        STEP_END=$(date +%s)
        STEP_DURATION=$((STEP_END - STEP_START))
        echo "build_strategy,$STEP_START,$STEP_END,$STEP_DURATION,success" >> ${{ steps.metrics-init.outputs.metrics_file }}
        echo "‚è±Ô∏è  Build strategy determination took: ${STEP_DURATION}s"
    
    - name: Build static library
      id: build-library
      if: steps.strategy.outputs.build_library == 'true'
      continue-on-error: true
      env:
        BUILD_TYPE: ${{ steps.config.outputs.build_type == 'debug' && 'Debug' || 'Release' }}
        VERBOSE: ${{ steps.config.outputs.save_logs == 'true' && 'true' || 'false' }}
      run: |
        STEP_START=$(date +%s)
        cd workspace/build
        echo "=== Building Static Library ==="
        echo "üèóÔ∏è  Build Type: $BUILD_TYPE"
        echo "üìù Verbose Logging: $VERBOSE"
        
        # Use the build script to build the library only
        if ./scripts/build.sh build; then
          BUILD_STATUS="success"
        else
          BUILD_STATUS="failure"
        fi

        # Record step completion
        STEP_END=$(date +%s)
        STEP_DURATION=$((STEP_END - STEP_START))
        echo "build_library,$STEP_START,$STEP_END,$STEP_DURATION,$BUILD_STATUS" >> ${{ steps.metrics-init.outputs.metrics_file }}
        echo "‚è±Ô∏è  Library build took: ${STEP_DURATION}s (Status: $BUILD_STATUS)"
        
        # Exit with appropriate code if build failed
        if [ "$BUILD_STATUS" = "failure" ]; then
          exit 1
        fi
    
    - name: Build application
      id: build-application
      if: steps.strategy.outputs.build_application == 'true'
      continue-on-error: true
      env:
        BUILD_TYPE: ${{ steps.config.outputs.build_type == 'debug' && 'Debug' || 'Release' }}
        VERBOSE: ${{ steps.config.outputs.save_logs == 'true' && 'true' || 'false' }}
      run: |
        STEP_START=$(date +%s)
        cd workspace/build
        echo "=== Building Application ==="
        echo "üèóÔ∏è  Build Type: $BUILD_TYPE"
        echo "üìù Verbose Logging: $VERBOSE"
        
        # The build script will build both library and application
        if [[ "${{ steps.strategy.outputs.build_library }}" != "true" ]]; then
          # If library wasn't built in previous step, build everything
          BUILD_RESULT=$(./scripts/build.sh build && echo "success" || echo "failure")
        else
          BUILD_RESULT="success"  # Application is built as part of library build
        fi
        
        # Record step completion
        STEP_END=$(date +%s)
        STEP_DURATION=$((STEP_END - STEP_START))
        echo "build_application,$STEP_START,$STEP_END,$STEP_DURATION,$BUILD_RESULT" >> ${{ steps.metrics-init.outputs.metrics_file }}
        echo "‚è±Ô∏è  Application build took: ${STEP_DURATION}s (Status: $BUILD_RESULT)"
        
        # Exit with appropriate code if build failed
        if [ "$BUILD_RESULT" = "failure" ]; then
          exit 1
        fi
    
    - name: Run tests
      id: run-tests
      continue-on-error: true
      env:
        BUILD_TYPE: ${{ steps.config.outputs.build_type == 'debug' && 'Debug' || 'Release' }}
        VERBOSE: ${{ steps.config.outputs.save_logs == 'true' && 'true' || 'false' }}
      run: |
        STEP_START=$(date +%s)
        cd workspace/build
        echo "=== Running Tests ==="
        echo "üèóÔ∏è  Build Type: $BUILD_TYPE"
        echo "üìù Verbose Logging: $VERBOSE"
        
        # Run tests using the build script
        if ./scripts/build.sh test; then
          TEST_STATUS="success"
        else
          TEST_STATUS="failure"
        fi
        
        # Record step completion
        STEP_END=$(date +%s)
        STEP_DURATION=$((STEP_END - STEP_START))
        echo "run_tests,$STEP_START,$STEP_END,$STEP_DURATION,$TEST_STATUS" >> ${{ steps.metrics-init.outputs.metrics_file }}
        echo "‚è±Ô∏è  Test execution took: ${STEP_DURATION}s (Status: $TEST_STATUS)"
        
        # Exit with appropriate code if tests failed
        if [ "$TEST_STATUS" = "failure" ]; then
          exit 1
        fi
    
    - name: Collect artifacts
      id: collect-artifacts
      run: |
        STEP_START=$(date +%s)
        cd workspace/build
        echo "=== Collecting Build Artifacts ==="
        
        # Create artifacts directory
        mkdir -p ../../artifacts
        
        # Copy build artifacts if they exist (created by build scripts)
        if [ -d "artifacts" ]; then
          cp -r artifacts/* ../../artifacts/
        fi
        
        # Also collect specific items
        if [ -d "../libs/calculator/lib" ]; then
          mkdir -p ../../artifacts/library
          cp -r ../libs/calculator/lib/* ../../artifacts/library/
        fi
        
        if [ -f "../application/calculator" ]; then
          mkdir -p ../../artifacts/application
          cp ../application/calculator ../../artifacts/application/
        fi
        
        # Show what we collected
        echo "Artifacts collected:"
        find ../../artifacts -type f 2>/dev/null || echo "No artifacts found"
        
        # Record step completion
        STEP_END=$(date +%s)
        STEP_DURATION=$((STEP_END - STEP_START))
        echo "collect_artifacts,$STEP_START,$STEP_END,$STEP_DURATION,success" >> ${{ steps.metrics-init.outputs.metrics_file }}
        echo "‚è±Ô∏è  Artifact collection took: ${STEP_DURATION}s"
    
    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: build-artifacts-${{ github.run_number }}
        path: artifacts/
        retention-days: ${{ env.BUILD_ARTIFACTS_RETENTION }}
    
    - name: Upload build logs
      if: steps.config.outputs.save_logs == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: build-logs-${{ github.run_number }}
        path: |
          workspace/build/logs/
          workspace/build/build.log
          workspace/*/build/
          ${{ steps.metrics-init.outputs.metrics_file }}
        retention-days: ${{ env.BUILD_ARTIFACTS_RETENTION }}
        if-no-files-found: warn
    
    - name: Cache build metrics for summary
      if: always()
      uses: actions/cache/save@v4
      with:
        path: ${{ steps.metrics-init.outputs.metrics_file }}
        key: build-metrics-${{ github.run_id }}-${{ github.run_number }}

  # Job for generating comprehensive build summary
  build-summary:
    needs: build
    if: always()  # Run even if build job fails
    runs-on: buildjet-16vcpu-ubuntu-2204
    
    steps:
    - name: Checkout for build summary action
      uses: actions/checkout@v4
    
    - name: Restore build metrics from cache
      uses: actions/cache/restore@v4
      with:
        path: /tmp/metrics/build_metrics.csv
        key: build-metrics-${{ github.run_id }}-${{ github.run_number }}
        fail-on-cache-miss: true
    
    - name: Generate build summary
      uses: ./.github/actions/build-summary
      with:
        build-type: ${{ needs.build.outputs.build-type }}
        save-logs: ${{ needs.build.outputs.save-logs }}
        artifacts-retention: ${{ inputs.artifacts_retention || '5' }}
        trigger-reason: ${{ needs.build.outputs.trigger-reason }}
        build-start-time: ${{ needs.build.outputs.build-start-time }}
        source-repo: ${{ needs.build.outputs.source-repo }}
        source-ref: ${{ needs.build.outputs.source-ref }}
        source-sha: ${{ needs.build.outputs.source-sha }}
        library-status: ${{ needs.build.outputs.library-status }}
        application-status: ${{ needs.build.outputs.application-status }}
        tests-status: ${{ needs.build.outputs.tests-status }}
        metrics-file: /tmp/metrics/build_metrics.csv

  # Job for final status validation
  status-check:
    needs: build
    if: always()  # Run even if build job fails
    runs-on: buildjet-16vcpu-ubuntu-2204
    
    steps:
    - name: Final build status check
      run: |
        echo "=== Final Build Status Check ==="
        
        # Check individual step outcomes from build job
        LIBRARY_STATUS="${{ needs.build.outputs.library-status }}"
        APPLICATION_STATUS="${{ needs.build.outputs.application-status }}"
        TESTS_STATUS="${{ needs.build.outputs.tests-status }}"
        
        echo "üìä Step Outcomes:"
        echo "  - Library: $LIBRARY_STATUS"
        echo "  - Application: $APPLICATION_STATUS" 
        echo "  - Tests: $TESTS_STATUS"
        
        # Determine if any critical step failed
        FAILED_STEPS=""
        
        if [[ "$LIBRARY_STATUS" == "failure" ]]; then
          FAILED_STEPS="$FAILED_STEPS library"
        fi
        
        if [[ "$APPLICATION_STATUS" == "failure" ]]; then
          FAILED_STEPS="$FAILED_STEPS application"
        fi
        
        if [[ "$TESTS_STATUS" == "failure" ]]; then
          FAILED_STEPS="$FAILED_STEPS tests"
        fi
        
        if [[ -n "$FAILED_STEPS" ]]; then
          echo "‚ùå Build FAILED - Failed steps:$FAILED_STEPS"
          echo "üö® Setting workflow status to failed"
          exit 1
        else
          echo "‚úÖ Build SUCCEEDED - All critical steps passed"
        fi

  # Job for posting build results to source PR
  notify:
    needs: [build, status-check]
    if: always() && github.event_name == 'repository_dispatch' && needs.build.outputs.pr-number != ''
    runs-on: buildjet-16vcpu-ubuntu-2204
    
    steps:
    - name: Debug values
      run: |
        echo "=== Debug Notify Job ==="
        echo "Event name: ${{ github.event_name }}"
        echo "Source repo: '${{ needs.build.outputs.source-repo }}'"
        echo "PR number: '${{ needs.build.outputs.pr-number }}'"
        echo "Build result: '${{ needs.build.result }}'"
        echo "Status-check result: '${{ needs.status-check.result }}'"
        echo "Build type: '${{ needs.build.outputs.build-type }}'"
        echo "Save logs: '${{ needs.build.outputs.save-logs }}'"
        echo "Library status: '${{ needs.build.outputs.library-status }}'"
        echo "Application status: '${{ needs.build.outputs.application-status }}'"
        echo "Tests status: '${{ needs.build.outputs.tests-status }}'"
        echo "Build start time: '${{ needs.build.outputs.build-start-time }}'"
        echo "Artifacts retention: '${{ inputs.artifacts_retention || '5' }}'"
    
    - name: Checkout for custom action
      uses: actions/checkout@v4
    
    - name: Post build results to source PR
      uses: ./.github/actions/post-build-results
      with:
        github-token: ${{ secrets.PAT_TOKEN }}
        source-repo: ${{ needs.build.outputs.source-repo }}
        pr-number: ${{ needs.build.outputs.pr-number }}
        build-type: ${{ needs.build.outputs.build-type }}
        save-logs: ${{ needs.build.outputs.save-logs }}
        build-status: ${{ needs.build.result }}
        library-status: ${{ needs.build.outputs.library-status }}
        application-status: ${{ needs.build.outputs.application-status }}
        tests-status: ${{ needs.build.outputs.tests-status }}
        build-start-time: ${{ needs.build.outputs.build-start-time }}
        artifacts-retention: ${{ inputs.artifacts_retention || '5' }}
